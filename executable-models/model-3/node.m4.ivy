#lang ivy1.7
include(`relation.m4.ivy')
object node = {
    # For some reason treating the following relation definitions as assignments in
    # an 'after init' block means that Ivy considers the possibility of the
    # relations having different values, when exploring possible prestates for
    # actions, though it seems like it should not.

    # Generated by relation.py
esyscmd(`python3 relation.py')dnl

    # These relations are state variables, and will
    # be updated during actions below.
    relation voted(SELF:id_t, VAL:val_t)
    relation accepted(SELF:id_t, VAL:val_t)
    relation confirmed(SELF:id_t, VAL:val_t)
    relation heard_vote(SELF:id_t, SRC:id_t, VAL:val_t)
    relation heard_accept(SELF:id_t, SRC:id_t, VAL:val_t)

    after init {
        voted (SELF, VAL) := false;
        accepted(SELF, VAL) := false;
        confirmed(SELF, VAL) := false;
        heard_vote(SELF, SRC, VAL) := false;
        heard_accept(SELF, SRC, VAL) := false;
    }

    # The remaining relations are definitions, used as
    # abbreviations inside logical formulas elsewhere.

    after init {
        voted(SELF, VAL) := false;
        accepted(SELF, VAL) := false;
        confirmed(SELF, VAL) := false;
        heard_vote(SELF, SRC, VAL) := false;
        heard_accept(SELF, SRC, VAL) := false;
    }

    action vote(self_id:id_t, val:val_t) =
    {
        require ~voted(self_id, val);
        voted(self_id, val) := true;
        heard_vote(self_id, self_id, val) := true;
        TRY_TO_ACCEPT_AND_CONFIRM(self_id, val)
    }

    action recv_vote(self_id:id_t, src:id_t, val:val_t) =
    {
        heard_vote(self_id, src, val) := true;
        TRY_TO_ACCEPT_AND_CONFIRM(self_id, val)
    }

    action recv_accept(self_id:id_t, src:id_t, val:val_t) =
    {
        heard_accept(self_id, src, val) := true;
        TRY_TO_ACCEPT_AND_CONFIRM(self_id, val)
    }
}

