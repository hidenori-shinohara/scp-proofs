#lang ivy1.7

# Provide udp-based message-receipt and route messages into nodes.
include udp
instance udp_net : udp_simple(id_t, msg_t)
export udp_net.recv

isolate network =
{
    relation is_quorum(S:nset)
    relation is_v_blocking(V:id_t, S:nset)

    relation node_accept_condition_1(NODE:id_t, QUORUM:nset, VALUE:val_t)
    definition node_accept_condition_1(NODE, QUORUM, VALUE) =
        is_quorum(QUORUM) &
        node.voted(NODE, VALUE) &
        member(NODE, QUORUM) &
        (forall OTHER. member(OTHER, QUORUM)
         -> (NODE = OTHER | node.heard_vote(NODE, OTHER, VALUE) | node.heard_accept(NODE, OTHER, VALUE)))

    relation node_accept_condition_2(NODE:id_t, S:nset, VALUE:val_t)
    definition node_accept_condition_2(NODE, S, VALUE) =
        is_v_blocking(NODE, S) &
        ~member(NODE, S) &
        (forall OTHER. member(OTHER, S) -> node.heard_accept(NODE, OTHER, VALUE))

    relation node_heard_quorum_accept_value(NODE:id_t, QUORUM:nset, VALUE:val_t)
    definition node_heard_quorum_accept_value(NODE, QUORUM, VALUE) =
        is_quorum(QUORUM) &
        member(NODE, QUORUM) &
        (forall OTHER. member(OTHER, QUORUM)
         -> (NODE = OTHER | node.heard_accept(NODE, OTHER, VALUE)))

    after init {
        is_quorum(S) := false;
        is_v_blocking(V, S) := false;
        member(V, S) := false;
    }
    # Deliver the message "src voted v" to dst.
    action deliver_vote(src:id_t, dst:id_t, v:val_t) =
    {
        call assume_cascade();
        require node.voted(src, v);
        call node.recv_vote(dst, src, v);
    }

    # Deliver the message "src accepted v" to dst.
    action deliver_accept(src:id_t, dst:id_t, v:val_t) =
    {
        call assume_cascade();
        require node.accepted(src, v);
        call node.recv_accept(dst, src, v);
    }

    action set_is_quorum(s:nset, b:bool) =
    {
        is_quorum(s) := b;
    }

    action set_is_v_blocking(v:id_t, s:nset, b:bool) =
    {
        is_v_blocking(v, s) := b;
    }

    action set_member(v:id_t, s:nset, b:bool) =
    {
        member(v, s) := b;
    }
# If every member of a quorum accepts V,
# then either
# 1) Every node has accepted V (not just in the quorum), or
# 2) There exists a node that hasn't accepted V, but its v-blocking set has accepted V, so it's going to accept it soon.
    action assume_cascade = {
        assume exists Q. (is_quorum(Q) & forall V. member(V, Q));
        assume forall Q, V. is_quorum(Q) & (exists N0 . member(N0,Q)) & (forall N . member(N,Q) -> node.accepted(N, V))
            -> (
                    (forall N1 . node.accepted(N1, V)) |
                    (exists N2, S . ~node.accepted(N2, V) & is_v_blocking(N2, S) &
                     (forall N3 . member(N3,S) -> node.accepted(N3, V))
                    )
               );
    }
    private {
        invariant node.heard_accept(SELF, SRC, VAL) -> node.accepted(SRC, VAL)
        invariant node.heard_vote(SELF, SRC, VAL) -> node.voted(SRC, VAL)
        invariant node.accepted(NODE, VAL) -> (exists OTHER. node.voted(OTHER, VAL))
        invariant node.confirmed(NODE, VAL) -> node.accepted(NODE, VAL)
        invariant [confirm_backward] (exists QUORUM. node_heard_quorum_accept_value(NODE, QUORUM, VALUE))
            -> node.confirmed(NODE, VALUE)
        invariant [accept_forward] node.accepted(NODE, VALUE)
        -> (exists S. node_accept_condition_1(NODE, S, VALUE) | node_accept_condition_2(NODE, S, VALUE))
    }
    invariant [eventually_same_candidate_set]
        (forall SRC, VALUE.
         (node.voted(SRC, VALUE) -> (forall DST. SRC = DST | node.heard_vote(DST, SRC, VALUE))) &
         (node.accepted(SRC, VALUE) -> (forall DST. SRC = DST | node.heard_accept(DST, SRC, VALUE))))
        -> (forall NODE1, NODE2, VALUE. node.confirmed(NODE1, VALUE) -> node.confirmed(NODE2, VALUE))
}
with id_t, udp_net, node, nset

