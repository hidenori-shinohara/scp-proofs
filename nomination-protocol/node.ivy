#lang ivy1.7

# id_t is the type of node ids
# self_id is the node of each node instance
# val_t is the type of values

isolate node = {

    relation voted(SELF:id_t, VAL:val_t)
    relation accepted(SELF:id_t, VAL:val_t)
    relation confirmed(SELF:id_t, VAL:val_t)
    relation heard_vote(SELF:id_t, SRC:id_t, VAL:val_t)
    relation heard_accept(SELF:id_t, SRC:id_t, VAL:val_t)

    after init {
    }

    action vote(self_id:id_t, v:val_t) =
    {
        voted(self_id, v) := true;
    }

    action recv_vote(self_id:id_t, src:id_t, val:val_t) =
    {
        heard_vote(self_id, src, val) := true;
        # Check if I can accept this!
        if (exists Q. network.is_quorum(Q) & member(self_id, Q) &
            (forall V. member(V, Q) -> (V = self_id | heard_vote(self_id, V, val) | heard_accept(self_id, V, val)))) {
            accepted(self_id, val) := true;
        };
        if (exists S. network.is_v_blocking(self_id, S) &
            (forall V. member(V, S) -> (V = self_id | heard_accept(self_id, V, val)))) {
            accepted(self_id, val) := true;
        };
        # Check if I can confirm this!
        if (exists Q. network.is_quorum(Q) & member(self_id, Q) &
            (forall V. member(V, Q) -> (V = self_id | heard_accept(self_id, V, val)))) {
            confirmed(self_id, val) := true;
        };
    }

    action recv_accept(self_id:id_t, src:id_t, val:val_t) =
    {
        heard_accept(self_id, src, val) := true;
        # Check if I can accept this!
        if (exists Q. network.is_quorum(Q) & member(self_id, Q) &
            (forall V. member(V, Q) -> (V = self_id | heard_vote(self_id, V, val) | heard_accept(self_id, V, val)))) {
            accepted(self_id, val) := true;
        };
        if (exists S. network.is_v_blocking(self_id, S) &
            (forall V. member(V, S) -> (V = self_id | heard_accept(self_id, V, val)))) {
            accepted(self_id, val) := true;
        };
        # Check if I can confirm this!
        if (exists Q. network.is_quorum(Q) & member(self_id, Q) &
            (forall V. member(V, Q) -> (V = self_id | heard_accept(self_id, V, val)))) {
            confirmed(self_id, val) := true;
        };
    }
    action check_confirmed(self_id:id_t, val:val_t) returns (b:bool)
    implement check_confirmed {
        b := confirmed(self_id, val);
    }
} with network, id_t, nset

