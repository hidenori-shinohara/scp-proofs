#lang ivy1.7

include(`relation.m4.ivy')

object node = {


    # It does not make much sense to talk about
    # a network containing only one node.
    axiom exists X:id_t, Y. X ~= Y

    relation member(X:id_t, S:set_t)
    axiom exists S. forall X. member(X, S)

    relation is_quorum(S:set_t)
    axiom (is_quorum(S) & is_quorum(T)) -> INTERSECT(S, T)
    axiom (forall X. member(X, S)) -> is_quorum(S)

    # These relations are state variables, and will
    # be updated during actions below.
    relation voted(SELF:id_t, VAL:val_t)
    relation accepted(SELF:id_t, VAL:val_t)
    relation confirmed(SELF:id_t, VAL:val_t)
    relation heard_vote(SELF:id_t, SRC:id_t, VAL:val_t)
    relation heard_accept(SELF:id_t, SRC:id_t, VAL:val_t)

    after init {
        voted (SELF, VAL) := false;
        accepted(SELF, VAL) := false;
        confirmed(SELF, VAL) := false;
        heard_vote(SELF, SRC, VAL) := false;
        heard_accept(SELF, SRC, VAL) := false;
    }

    action vote(self_id:id_t, val:val_t) =
    {
        require ~voted(self_id, val);
        voted(self_id, val) := true;
        heard_vote(self_id, self_id, val) := true;
        TRY_TO_ACCEPT_AND_CONFIRM(self_id, val)
    }

    action recv_vote(self_id:id_t, src:id_t, val:val_t) =
    {
        heard_vote(self_id, src, val) := true;
        TRY_TO_ACCEPT_AND_CONFIRM(self_id, val)
    }

    action recv_accept(self_id:id_t, src:id_t, val:val_t) =
    {
        heard_accept(self_id, src, val) := true;
        TRY_TO_ACCEPT_AND_CONFIRM(self_id, val)
    }
}

