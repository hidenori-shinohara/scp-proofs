#lang ivy1.7

isolate network = {

    # Network can be called src a node sending a message.
    action broadcast_vote(src:id_t, value:val_t)
    action broadcast_accept(src:id_t, value:val_t)

    # Network can also be "called" spontaneously to note the
    # delivery of a message at a node.
    action deliver_vote(src:id_t, dst:id_t, value:val_t)
    action deliver_accept(src:id_t, dst:id_t, value:val_t)

    # Adding quorums in the network module lets us not worry about quorum slices.
    # In the actual network, each node's quorum slices are public information
    # and the calculation of quorums from quorum slices does not depend on
    # who does the calculation, so it seems okay to put this here.
    relation is_quorum(S:nset)
    relation intersect(S:nset, T:nset)
    axiom [intersection_basic_prop] nset.member(V, S1) & nset.member(V, S2) -> intersect(S1, S2)
    # See Abstraction 1 & 2 on https://github.com/stellar/scp-proofs
    axiom [quorum_intersection] is_quorum(S1) & is_quorum(S2) -> intersect(S1, S2)
    individual universe : nset
    axiom forall V. nset.member(V, universe)

    # The set of all nodes is a quorum
    # because every quorum slice is contained in the set of all nodes.
    # See Abstraction 3 of https://github.com/stellar/scp-proofs
    axiom is_quorum(universe)

    relation node_heard_quorum_accept_value(NODE:id_t, QUORUM:nset, VALUE:val_t)
    definition node_heard_quorum_accept_value(NODE, QUORUM, VALUE) =
       is_quorum(QUORUM) &
       nset.member(NODE, QUORUM) &
       (forall OTHER. nset.member(OTHER, QUORUM)
         -> (NODE = OTHER | node(NODE).heard_accept(OTHER, VALUE)))

    relation node_heard_quorum_vote_or_accept_value(NODE:id_t, QUORUM:nset, VALUE:val_t)
    definition node_heard_quorum_vote_or_accept_value(NODE, QUORUM, VALUE) =
       is_quorum(QUORUM) &
       nset.member(NODE, QUORUM) &
       (forall OTHER. nset.member(OTHER, QUORUM)
         -> (NODE = OTHER | node(NODE).heard_vote(OTHER, VALUE) | node(NODE).heard_accept(OTHER, VALUE)))

    # If an intact node is blocked by a set of nodes, then the set contains an intact node.
    # See Abstraction 5 of https://github.com/stellar/scp-proofs
    relation is_blocking(V:id_t, B:nset)
    axiom (exists V. is_blocking(V, B)) -> exists V2. nset.member(V2, B)


    relation node_heard_v_blocking_accept(NODE:id_t, BLOCKING:nset, VALUE:val_t)
    definition node_heard_v_blocking_accept(NODE, BLOCKING, VALUE) =
       is_blocking(NODE, BLOCKING) &
       (forall OTHER. nset.member(OTHER, BLOCKING) -> node(NODE).heard_accept(OTHER, VALUE))

    specification {
        relation have_broadcast_vote(SRC:id_t, VALUE:val_t)
        relation have_broadcast_accept(SRC:id_t, VALUE:val_t)
        relation have_delivered_vote(SRC:id_t, DST:id_t, VALUE:val_t)
        relation have_delivered_accept(SRC:id_t, DST:id_t, VALUE:val_t)

        after init {
            have_broadcast_vote(SRC, VALUE) := false;
            have_broadcast_accept(SRC, VALUE) := false;
            have_delivered_vote(SRC, DST, VALUE) := false;
            have_delivered_accept(SRC, DST, VALUE) := false;
        }

        before broadcast_vote {
            require node(src).have_voted(value);
        }
        after broadcast_vote {
            have_broadcast_vote(src, value) := true;
        }

        before deliver_vote {
            require have_broadcast_vote(src, value);
            # Remove this next condition to allow message duplication.
            require ~have_delivered_vote(src, dst, value);
        }
        after deliver_vote {
            call node(dst).recv_vote(src, value);
            have_delivered_vote(src, dst, value) := true;
        }

        before broadcast_accept {
            require node(src).have_accepted(value);
        }
        after broadcast_accept {
            have_broadcast_accept(src, value) := true;
        }

        before deliver_accept {
            require have_broadcast_accept(src, value);
            # Remove this next condition to allow message duplication.
            require ~have_delivered_accept(src, dst, value);
        }
        after deliver_accept {
            call node(dst).recv_accept(src, value);
            have_delivered_accept(src, dst, value) := true;
        }

        #######
        ####### ***INVARIANT***
        #######

# IVy can't seem to prove this.
# The setup is wrong and/or I haven't added enough invariants.
#        invariant [if_confirmed_everyone_will_confirm]
#            node(ID).have_confirmed(VALUE)
#                -> (forall OTHER_ID . node(OTHER_ID).have_confirmed(VALUE)) |
#                   (exists SRC, DST . have_broadcast_vote(SRC, VALUE) &
#                                      ~have_delivered_vote(SRC, DST, VALUE)) |
#                   (exists SRC, DST . have_broadcast_accept(SRC, VALUE) &
#                                      ~have_delivered_accept(SRC, DST, VALUE))

# IVy can't seem to prove this.
# The setup is wrong and/or I haven't added enough invariants.
#        invariant [eventually_at_least_one_candidate_value]
#            node(ID).have_voted(VALUE)
#                -> node(ID).have_confirmed(VALUE) |
#                   (exists SRC, DST . have_broadcast_vote(SRC, VALUE) &
#                                      ~have_delivered_vote(SRC, DST, VALUE)) |
#                   (exists SRC, DST . have_broadcast_accept(SRC, VALUE) &
#                                      ~have_delivered_accept(SRC, DST, VALUE))

        # Try to prove that once all the messages have been delivered,
        # every node will have confirmed the exact same nomination statements.
        # Again, IVy can't seem to prove this.
        invariant [eventually_same_candidate_set]
            (forall SRC, DST, VALUE.
                (have_broadcast_vote(SRC, VALUE) -> have_delivered_vote(SRC, DST, VALUE)) &
                (have_broadcast_accept(SRC, VALUE) -> have_delivered_accept(SRC, DST, VALUE)))
            -> (forall NODE1, NODE2, VALUE. node(NODE1).have_confirmed(VALUE) -> node(NODE2).have_confirmed(VALUE))
    }

    implementation {
        implement broadcast_vote {
        }
        implement deliver_vote {
        }
    }

    private {
        # Seemingly trivial invariants.
        # For some reason, IVy seems to like to come up with CTIs that violate these,
        # so it's probably a good idea to keep these here.
        invariant have_broadcast_vote(NODE, VALUE) -> node(NODE).have_voted(VALUE)
        invariant have_delivered_vote(SRC, DST, VALUE) -> node(SRC).have_voted(VALUE)
        invariant have_delivered_vote(SRC, DST, VALUE) -> node(DST).heard_vote(SRC, VALUE)
        invariant have_delivered_vote(SRC, DST, VALUE) -> have_broadcast_vote(SRC, VALUE)
        invariant have_delivered_accept(SRC, DST, VALUE) -> node(SRC).have_accepted(VALUE)
        invariant have_delivered_accept(SRC, DST, VALUE) -> node(DST).heard_accept(SRC, VALUE)
        invariant have_delivered_accept(SRC, DST, VALUE) -> have_broadcast_accept(SRC, VALUE)
        invariant have_broadcast_accept(NODE, VALUE) -> node(NODE).have_accepted(VALUE)
        invariant node(ID).have_accepted(VALUE) ->
                    exists OTHER. node(OTHER).have_voted(VALUE)
        invariant have_delivered_accept(SRC, DST, VALUE)
                    -> exists OTHER. node(OTHER).have_voted(VALUE)
        invariant have_delivered_accept(SRC, DST, VALUE)
                    -> node(SRC).have_accepted(VALUE)
        invariant (SRC ~= DST & have_delivered_accept(SRC, DST, VALUE))
                    -> node(DST).heard_accept(SRC, VALUE)
        invariant node(ID).have_confirmed(VALUE) ->
                    exists OTHER. node(OTHER).have_voted(VALUE)
        invariant have_delivered_accept(SRC, DST, VALUE)
                    -> have_broadcast_accept(SRC, VALUE) & node(DST).heard_accept(SRC, VALUE)
        invariant (A ~= B & node(A).heard_vote(B, VALUE))
                    -> node(B).have_voted(VALUE) &
                        have_broadcast_vote(B, VALUE)
        invariant (A ~= B & node(A).heard_accept(B, VALUE))
                    -> node(B).have_accepted(VALUE) &
                        have_broadcast_accept(B, VALUE)

        invariant [accept_forward] node(NODE).have_accepted(VALUE)
                    -> (
                        (exists QUORUM. node_heard_quorum_vote_or_accept_value(NODE, QUORUM, VALUE)) |
                        (exists BLOCKING. node_heard_v_blocking_accept(NODE, BLOCKING, VALUE))
                    )

        # If NODE has confirmed VALUE,
        # It must be the case that NODE has accepted VALUE
        # * NODE has accepted VALUE, and
        # * There exists a quorum such that
        #     * NODE is in the quorum, and
        #     * NODE has heard from every other node in the quorum that they accepted VALUE.
        # This is just the definition of confirming from the white paper.
        invariant [confirm_forward] node(NODE).have_confirmed(VALUE)
                    -> (node(NODE).have_accepted(VALUE) &
                       (exists QUORUM.  node_heard_quorum_accept_value(NODE, QUORUM, VALUE)))
        invariant [confirm_backward] (node(NODE).have_accepted(VALUE) &
                       (exists QUORUM.  node_heard_quorum_accept_value(NODE, QUORUM, VALUE)))
                    -> node(NODE).have_confirmed(VALUE)

    }
} with node
