#lang ivy1.7

isolate network =
{
    relation is_quorum(S:nset)
    relation is_v_blocking(V:id_t, S:nset)

# network_started is important since
# without this it'd be much more difficult to reason about voting, accepting, confirming.
# e.g., Checking if there _was_ a quorum when a node confirmed something seems hard.
    relation network_started

    relation node_accept_condition_1(NODE:id_t, QUORUM:nset, VALUE:val_t)
    definition node_accept_condition_1(NODE, QUORUM, VALUE) =
        is_quorum(QUORUM) &
        member(NODE, QUORUM) &
        (forall OTHER. member(OTHER, QUORUM)
         -> ((NODE = OTHER & node.voted(NODE, VALUE)) |
             node.heard_vote(NODE, OTHER, VALUE) |
             node.heard_accept(NODE, OTHER, VALUE)))

    relation node_accept_condition_2(NODE:id_t, S:nset, VALUE:val_t)
    definition node_accept_condition_2(NODE, S, VALUE) =
        is_v_blocking(NODE, S) &
        ~member(NODE, S) &
        (forall OTHER. member(OTHER, S) -> node.heard_accept(NODE, OTHER, VALUE))

    relation node_heard_quorum_accept_value(NODE:id_t, QUORUM:nset, VALUE:val_t)
    definition node_heard_quorum_accept_value(NODE, QUORUM, VALUE) =
        is_quorum(QUORUM) &
        member(NODE, QUORUM) &
        node.accepted(NODE, VALUE) &
        (forall OTHER. member(OTHER, QUORUM) -> (NODE = OTHER | node.heard_accept(NODE, OTHER, VALUE)))

    after init {
        is_quorum(S) := false;
        is_v_blocking(V, S) := false;
        member(V, S) := false;
        network_started := false;
    }

    # Deliver the message "src voted v" to dst.
    action deliver_vote(src:id_t, dst:id_t, v:val_t) =
    {
        call assume_axioms();
        # The network can choose to deliver a message of src voting v to dst
        # as long as
        # 1) src has actually voted v.
        # 2) dst hasn't received the message.
        # This allows reordering of messages,
        # and makes sure that each message only gets sent once.
        # We never set `heard_vote` to false after setting it to true,
        # and that makes it impossible for the time to go backwards.
        require node.voted(src, v);
        require ~node.heard_vote(dst, src, v);
        call node.recv_vote(dst, src, v);
    }

    # Deliver the message "src accepted v" to dst.
    action deliver_accept(src:id_t, dst:id_t, v:val_t) =
    {
        call assume_axioms();
        # The network can choose to deliver a message of src accepting v to dst
        # as long as
        # 1) src has actually accepted v.
        # 2) dst hasn't received the message.
        # This allows reordering of messages,
        # and makes sure that each message only gets sent once.
        # We never set `heard_accept` to false after setting it to true,
        # and that makes it impossible for the time to go backwards.
        require node.accepted(src, v);
        require ~node.heard_accept(dst, src, v);
        call node.recv_accept(dst, src, v);
    }

    # The network can set quorums, v-blocking sets before the network starts.
    # This is useful for extracted code because we can manually configure the network.
    action set_is_quorum(s:nset, b:bool) =
    {
        require ~network_started;
        is_quorum(s) := b;
    }

    action set_is_v_blocking(v:id_t, s:nset, b:bool) =
    {
        require ~network_started;
        is_v_blocking(v, s) := b;
    }

    action set_member(v:id_t, s:nset, b:bool) =
    {
        require ~network_started;
        member(v, s) := b;
    }

    action start_network =
    {
        require ~network_started;
        network_started := true;
    }

    # This ensures that the quorum & v-blocking set configuration is "sane"
    # (e.g., the set of all nodes MUST be a quorum by the definition of a quorum)
    # The axioms here are taken from stellar/scp-proofs.
    # We always run this when the network delivers messages and nodes start voting.
    action assume_axioms = {
        # If network_started=true,
        # quorums and v-blocking sets will no longer change.
        assume network_started;

        # The following axioms are taken from
        # https://github.com/stellar/scp-proofs/blob/master/README.md#abstractions

        # Axiom 1, 2: Quorum intersection
        # In this simplified model, every node becomes intact.
        assume forall Q1, Q2. ((is_quorum(Q1) & is_quorum(Q2)) -> exists V. member(V, Q1) & member(V, Q2));

        # Axiom 3: The set of all nodes must be a quorum.
        assume exists Q. (is_quorum(Q) & forall V. member(V, Q));

        # Axiom 4: Cascade theorem
        assume forall Q, V. is_quorum(Q) & (exists N0 . member(N0,Q)) & (forall N . member(N,Q) -> node.accepted(N, V))
            -> (
                    (forall N1 . node.accepted(N1, V)) |
                    (exists N2, S . ~node.accepted(N2, V) & is_v_blocking(N2, S) &
                     (forall N3 . member(N3,S) -> node.accepted(N3, V))
                    )
               );

        # Axiom 5: V-blocking sets must be nonempty
        assume is_v_blocking(V, S) -> exists W. member(W, S)
    }

    # Preliminary invariants.
    # These are not the properties that we ultimately care about
    # but telling Ivy about these properties helps Ivy prove things that we care about.
    # These can be thought of as "lemmas" in mathematics.
    private {
        invariant node.voted(SRC, VAL) -> network_started
        invariant node.accepted(SRC, VAL) -> network_started
        invariant node.confirmed(SRC, VAL) -> network_started
        invariant node.have_candidate(SRC) -> network_started
        invariant node.heard_accept(SELF, SRC, VAL) -> network_started
        invariant node.heard_vote(SELF, SRC, VAL) -> network_started

        invariant node.heard_accept(SELF, SRC, VAL) -> node.accepted(SRC, VAL)
        invariant node.heard_vote(SELF, SRC, VAL) -> node.voted(SRC, VAL)
        invariant node.accepted(NODE, VAL) -> (exists OTHER. node.voted(OTHER, VAL))
        invariant node.confirmed(NODE, VAL) -> node.accepted(NODE, VAL)
        invariant node.confirmed(NODE, VAL) -> 
            (
                (forall OTHER. NODE = OTHER) |
                (exists OTHER. (NODE ~= OTHER & node.accepted(OTHER, VAL)))
            )

        invariant [confirm_backward] (exists QUORUM. node_heard_quorum_accept_value(NODE, QUORUM, VALUE))
            -> node.confirmed(NODE, VALUE)

        invariant [confirm_forward]
            node.confirmed(NODE, VALUE) ->
            (exists QUORUM. node_heard_quorum_accept_value(NODE, QUORUM, VALUE))

        invariant [accept_forward] node.accepted(NODE, VALUE)
            -> (exists S. node_accept_condition_1(NODE, S, VALUE) | node_accept_condition_2(NODE, S, VALUE))
    }
    # Make sure that after all messages have been delivered, every node confirms the same candidate values.
    # This is NOT temporal logic because it doesn't guarantee that all messages will be delivered.
    # This is the same assumption that the white paper has. (See P.7)
    # "As is common for asynchronous systems, we assume the network eventually delivers messages between well-behaved nodes, but can otherwise arbitrarily delay or reorder messages."
    # Ivy can't prove this property yet.
    # This is because Ivy seems to think that there is a situation that start with a state that satisfies this property
    # and transitions into a state that doesn't satisfy this property.
    # In many cases, the first state in such examples cannot possibly happen.
    # Therefore, we need to tell Ivy that they can't happen through the private invariants above.
    invariant [same_candidate_set_after_all_messages_delivered]
        (forall SRC, VALUE.
         (node.voted(SRC, VALUE) -> (forall DST. SRC = DST | node.heard_vote(DST, SRC, VALUE))) &
         (node.accepted(SRC, VALUE) -> (forall DST. SRC = DST | node.heard_accept(DST, SRC, VALUE))))
            -> (forall NODE1, NODE2, VALUE. node.confirmed(NODE1, VALUE) -> node.confirmed(NODE2, VALUE))
}
with id_t, node, nset
