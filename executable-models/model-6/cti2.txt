confirm_same_after_sufficient_messages ... FAIL

[
    node.heard_vote(2,2,0) = true
    Sets 1-15 are quorums.
    Set 0 isn't a quorum.
    No set blocks any node.
    All nodes are well-behaved, intertwined, and intact!
    node.accepted(2,0) = true
    node.confirmed(2,0) = true
    node.voted(2,0) = true
    node.ready_to_accept_but_have_not_accepted(2,0) = false
    node.ready_to_confirm_but_have_not_confirmed(2,0) = false
    node.heard_accept(3,2,0) = true
    node.heard_accept(1,2,0) = true
    node.heard_accept(2,2,0) = true

    Set 0: [3, 1]
    Set 8: [0, 3, 1, 2]
    Set 1-7, 9-15: [2]
]
call network.deliver_accept

{
    [
        fml:src = 2
        fml:v = 0
        fml:dst = 0
    ]
    network.ivy: line 16: assume node.accepted(fml:src,fml:v)

    network.ivy: line 17: assume ~node.heard_accept(fml:dst,fml:src,fml:v)

    network.ivy: line 18: call node.recv_accept(fml:dst, fml:src, fml:v)
    {
        [
            fml:val = 0
            fml:src_a = 2
            fml:self_id = 0
        ]
        node.ivy: line 164: node.heard_accept(fml:self_id,fml:src,fml:val) := true

        [
            node.heard_accept(0,2,0) = true
        ]
        node.ivy: line 172: call node.assume_cascade_theorem
        {
            node.ivy: line 130: assume node.quorum_containing_intact_nodes(node.q0) & node.every_intact_node_in_this_set_accepted(node.q0,node.v0) -> node.accepted_by_every_intact_node(node.v0) | (exists S,N2. node.intact(N2) & ~node.accepted(N2,node.v0) & node.is_v_blocking(N2,S) & node.only_contains_intact_nodes_that_accepted(S,node.v0))

        }

    }

}


