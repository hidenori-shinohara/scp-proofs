#lang ivy1.7

object node = {
    # For some reason treating the following relation definitions as assignments in
    # an 'after init' block means that Ivy considers the possibility of the
    # relations having different values, when exploring possible prestates for
    # actions, though it seems like it should not.

    # Generated by relation.py
    relation member(X:id_t, S:set_t)
    definition member(X:id_t, S:set_t) =
        (X=0&S=1)|(X=0&S=3)|(X=0&S=5)|(X=0&S=7)|(X=0&S=9)|(X=0&S=11)|(X=0&S=13)|(X=0&S=15)|(X=1&S=2)|(X=1&S=3)|(X=1&S=6)|(X=1&S=7)|(X=1&S=10)|(X=1&S=11)|(X=1&S=14)|(X=1&S=15)|(X=2&S=4)|(X=2&S=5)|(X=2&S=6)|(X=2&S=7)|(X=2&S=12)|(X=2&S=13)|(X=2&S=14)|(X=2&S=15)|(X=3&S=8)|(X=3&S=9)|(X=3&S=10)|(X=3&S=11)|(X=3&S=12)|(X=3&S=13)|(X=3&S=14)|(X=3&S=15)

    relation is_quorum(S:set_t)
    definition is_quorum(S:set_t) =
        (S=7)|(S=11)|(S=13)|(S=14)|(S=15)

    relation is_v_blocking(X:id_t, S:set_t)
    definition is_v_blocking(X:id_t, S:set_t) =
        ~((X=0&S=0)|(X=0&S=2)|(X=0&S=4)|(X=0&S=8)|(X=1&S=0)|(X=1&S=1)|(X=1&S=4)|(X=1&S=8)|(X=2&S=0)|(X=2&S=1)|(X=2&S=2)|(X=2&S=8)|(X=3&S=0)|(X=3&S=1)|(X=3&S=2)|(X=3&S=4))

    # These relations are state variables, and will
    # be updated during actions below.
    relation voted(SELF:id_t, VAL:val_t)
    relation accepted(SELF:id_t, VAL:val_t)
    relation confirmed(SELF:id_t, VAL:val_t)
    relation heard_vote(SELF:id_t, SRC:id_t, VAL:val_t)
    relation heard_accept(SELF:id_t, SRC:id_t, VAL:val_t)

    after init {
        voted (SELF, VAL) := false;
        accepted(SELF, VAL) := false;
        confirmed(SELF, VAL) := false;
        heard_vote(SELF, SRC, VAL) := false;
        heard_accept(SELF, SRC, VAL) := false;
    }

    # The remaining relations are definitions, used as
    # abbreviations inside logical formulas elsewhere.

    after init {
        voted(SELF, VAL) := false;
        accepted(SELF, VAL) := false;
        confirmed(SELF, VAL) := false;
        heard_vote(SELF, SRC, VAL) := false;
        heard_accept(SELF, SRC, VAL) := false;
    }

    action vote(self_id:id_t, val:val_t) =
    {
        require ~voted(self_id, val);
        voted(self_id, val) := true;
        heard_vote(self_id, self_id, val) := true;
        if ~node.accepted(self_id, val) & (exists QUORUM_OF_self_id. (node.is_quorum(QUORUM_OF_self_id) & node.member(self_id, QUORUM_OF_self_id) & (forall NODE_IN_QUORUM_OF_self_id. node.member(NODE_IN_QUORUM_OF_self_id, QUORUM_OF_self_id) -> node.heard_vote(self_id, NODE_IN_QUORUM_OF_self_id, val) | node.heard_accept(self_id, NODE_IN_QUORUM_OF_self_id, val))) | (exists SET_BLOCKING_self_id.  (node.is_v_blocking(self_id, SET_BLOCKING_self_id) & (forall NODE_IN_SET_BLOCKING_self_id. node.member(NODE_IN_SET_BLOCKING_self_id, SET_BLOCKING_self_id) -> node.heard_accept(self_id, NODE_IN_SET_BLOCKING_self_id, val))))) {
            node.accepted(self_id, val) := true;
            node.heard_accept(self_id, self_id, val) := true;
        };
        if ~node.confirmed(self_id, val) & exists QUORUM_OF_self_id. (node.is_quorum(QUORUM_OF_self_id) & node.member(self_id, QUORUM_OF_self_id) & (forall NODE_IN_QUORUM_OF_self_id. node.member(NODE_IN_QUORUM_OF_self_id, QUORUM_OF_self_id) -> node.heard_accept(self_id, NODE_IN_QUORUM_OF_self_id, val))) {
            node.confirmed(self_id, val) := true;
        };
    }

    action recv_vote(self_id:id_t, src:id_t, val:val_t) =
    {
        heard_vote(self_id, src, val) := true;
        if ~node.accepted(self_id, val) & (exists QUORUM_OF_self_id. (node.is_quorum(QUORUM_OF_self_id) & node.member(self_id, QUORUM_OF_self_id) & (forall NODE_IN_QUORUM_OF_self_id. node.member(NODE_IN_QUORUM_OF_self_id, QUORUM_OF_self_id) -> node.heard_vote(self_id, NODE_IN_QUORUM_OF_self_id, val) | node.heard_accept(self_id, NODE_IN_QUORUM_OF_self_id, val))) | (exists SET_BLOCKING_self_id.  (node.is_v_blocking(self_id, SET_BLOCKING_self_id) & (forall NODE_IN_SET_BLOCKING_self_id. node.member(NODE_IN_SET_BLOCKING_self_id, SET_BLOCKING_self_id) -> node.heard_accept(self_id, NODE_IN_SET_BLOCKING_self_id, val))))) {
            node.accepted(self_id, val) := true;
            node.heard_accept(self_id, self_id, val) := true;
        };
        if ~node.confirmed(self_id, val) & exists QUORUM_OF_self_id. (node.is_quorum(QUORUM_OF_self_id) & node.member(self_id, QUORUM_OF_self_id) & (forall NODE_IN_QUORUM_OF_self_id. node.member(NODE_IN_QUORUM_OF_self_id, QUORUM_OF_self_id) -> node.heard_accept(self_id, NODE_IN_QUORUM_OF_self_id, val))) {
            node.confirmed(self_id, val) := true;
        };
    }

    action recv_accept(self_id:id_t, src:id_t, val:val_t) =
    {
        heard_accept(self_id, src, val) := true;
        if ~node.accepted(self_id, val) & (exists QUORUM_OF_self_id. (node.is_quorum(QUORUM_OF_self_id) & node.member(self_id, QUORUM_OF_self_id) & (forall NODE_IN_QUORUM_OF_self_id. node.member(NODE_IN_QUORUM_OF_self_id, QUORUM_OF_self_id) -> node.heard_vote(self_id, NODE_IN_QUORUM_OF_self_id, val) | node.heard_accept(self_id, NODE_IN_QUORUM_OF_self_id, val))) | (exists SET_BLOCKING_self_id.  (node.is_v_blocking(self_id, SET_BLOCKING_self_id) & (forall NODE_IN_SET_BLOCKING_self_id. node.member(NODE_IN_SET_BLOCKING_self_id, SET_BLOCKING_self_id) -> node.heard_accept(self_id, NODE_IN_SET_BLOCKING_self_id, val))))) {
            node.accepted(self_id, val) := true;
            node.heard_accept(self_id, self_id, val) := true;
        };
        if ~node.confirmed(self_id, val) & exists QUORUM_OF_self_id. (node.is_quorum(QUORUM_OF_self_id) & node.member(self_id, QUORUM_OF_self_id) & (forall NODE_IN_QUORUM_OF_self_id. node.member(NODE_IN_QUORUM_OF_self_id, QUORUM_OF_self_id) -> node.heard_accept(self_id, NODE_IN_QUORUM_OF_self_id, val))) {
            node.confirmed(self_id, val) := true;
        };
    }
}

